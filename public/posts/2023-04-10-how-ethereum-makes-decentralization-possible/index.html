<!doctype html><html lang=en dir=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>The Rise of ZK-EVMs: How Ethereum's Multi-Client Philosophy Enables Continued Decentralization | Ram's Website</title>
<meta name=keywords content><meta name=description content="My thoughts on EVMs Multi Client repository
One important aspect of Ethereum&rsquo;s security and decentralization is its multi-client philosophy. Instead of relying on a single reference client, Ethereum has a specification written in Python and multiple independent implementations of the spec called clients. Each node runs a consensus client to validate blocks and an execution client to check state transitions. Currently, no single client makes up more than two-thirds of either category. This ensures that bugs in any one client will not cripple the network."><meta name=author content="Me"><link rel=canonical href=http://localhost:1313/posts/2023-04-10-how-ethereum-makes-decentralization-possible/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as=style><link rel=icon href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=http://localhost:1313/posts/2023-04-10-how-ethereum-makes-decentralization-possible/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="The Rise of ZK-EVMs: How Ethereum's Multi-Client Philosophy Enables Continued Decentralization"><meta property="og:description" content="My thoughts on EVMs Multi Client repository
One important aspect of Ethereum&rsquo;s security and decentralization is its multi-client philosophy. Instead of relying on a single reference client, Ethereum has a specification written in Python and multiple independent implementations of the spec called clients. Each node runs a consensus client to validate blocks and an execution client to check state transitions. Currently, no single client makes up more than two-thirds of either category. This ensures that bugs in any one client will not cripple the network."><meta property="og:type" content="article"><meta property="og:url" content="http://localhost:1313/posts/2023-04-10-how-ethereum-makes-decentralization-possible/"><meta property="og:image" content="http://localhost:1313/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-04-10T00:00:00+00:00"><meta property="article:modified_time" content="2023-04-10T00:00:00+00:00"><meta property="og:site_name" content="ram's website"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://localhost:1313/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="The Rise of ZK-EVMs: How Ethereum's Multi-Client Philosophy Enables Continued Decentralization"><meta name=twitter:description content="My thoughts on EVMs Multi Client repository
One important aspect of Ethereum&rsquo;s security and decentralization is its multi-client philosophy. Instead of relying on a single reference client, Ethereum has a specification written in Python and multiple independent implementations of the spec called clients. Each node runs a consensus client to validate blocks and an execution client to check state transitions. Currently, no single client makes up more than two-thirds of either category. This ensures that bugs in any one client will not cripple the network."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://localhost:1313/posts/"},{"@type":"ListItem","position":2,"name":"The Rise of ZK-EVMs: How Ethereum's Multi-Client Philosophy Enables Continued Decentralization","item":"http://localhost:1313/posts/2023-04-10-how-ethereum-makes-decentralization-possible/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"The Rise of ZK-EVMs: How Ethereum's Multi-Client Philosophy Enables Continued Decentralization","name":"The Rise of ZK-EVMs: How Ethereum\u0027s Multi-Client Philosophy Enables Continued Decentralization","description":"My thoughts on EVMs Multi Client repository One important aspect of Ethereum\u0026rsquo;s security and decentralization is its multi-client philosophy. Instead of relying on a single reference client, Ethereum has a specification written in Python and multiple independent implementations of the spec called clients. Each node runs a consensus client to validate blocks and an execution client to check state transitions. Currently, no single client makes up more than two-thirds of either category. This ensures that bugs in any one client will not cripple the network.\n","keywords":[],"articleBody":"My thoughts on EVMs Multi Client repository One important aspect of Ethereum’s security and decentralization is its multi-client philosophy. Instead of relying on a single reference client, Ethereum has a specification written in Python and multiple independent implementations of the spec called clients. Each node runs a consensus client to validate blocks and an execution client to check state transitions. Currently, no single client makes up more than two-thirds of either category. This ensures that bugs in any one client will not cripple the network.\nAn upcoming transition in Ethereum is the rise of Zero-Knowledge Ethereum Virtual Machines or ZK-EVMs. ZK-EVMs use zero-knowledge proofs to verify EVM execution. They are currently used by layer 2 protocols called ZK rollups to scale Ethereum. In the future, ZK-EVMs could also be used to verify layer 1 Ethereum blocks. This raises the question of how ZK-EVMs will fit into Ethereum’s multi-client philosophy. While there are multiple ZK-EVM implementations, making them work together as “multi-clients” will be challenging. However, the benefits may outweigh the costs.\nWhy did Ethereum adopt a multi-client philosophy?\nEthereum’s multi-client philosophy improves both technical and political decentralization.\nTechnically, it reduces the risk of bugs in a single client disrupting the network. For example, if there was only one client, a catastrophic bug could cripple the entire network. With multiple clients, the network is more resilient. While multi-clients introduce the risk of consensus failures where clients disagree, in practice there are always multiple versions of a single client. So multi-clients likely reduce risk overall.\nPolitically, multi-clients prevent too much control from concentrating with any one team. If there was only one client, its developers would have significant power over the protocol. They could propose controversial changes or threaten to quit if they don’t get their way. Multi-clients make it harder for any one group to control the protocol.\nHow will ZK-EVMs be used on layer 1?\nThere are two options for using ZK-EVMs on layer 1:\nConstrict layer 1 and force activity to layer 2. This would limit layer 1 to verifying SNARKs and facilitating transfers between layer 2s. While this could work, it may not reduce costs enough for most users to verify the chain and it risks breaking compatibility with existing applications.\nUse ZK-EVMs to SNARK-verify layer 1. ZK-EVMs could generate proofs that verify the EVM execution and consensus of layer 1 blocks. This is challenging to implement but technically feasible and allows layer 1 to remain useful. The main question is which ZK-EVMs to use:\nSingle ZK-EVM: Pick one ZK-EVM to verify all blocks. This sacrifices the benefits of multiple clients.\nClosed multi ZK-EVM: Choose a fixed set of ZK-EVMs and require proofs from a majority to verify blocks. This limits innovation in new ZK-EVMs.\nOpen multi ZK-EVM: Different clients use different ZK-EVMs and wait for compatible proofs to verify blocks. This is ideal but introduces latency and data inefficiency challenges. With careful protocol design and aggregation methods, these challenges can be addressed.\nUsing ZK-EVMs to SNARK-verify layer 1 also allows greatly increasing layer 1 capacity since clients no longer need to re-execute every transaction.\nSo purely, i will say that\nAn open multi-client ZK-EVM ecosystem will require substantial work but many of the necessary technologies already exist or are in development. Multiple ZK-EVM implementations, light clients becoming full SNARK-verifiers, gradual transitions to SNARKs, and aggregation methods will all help in building this ecosystem.\nWhile ZK-EVMs still need to become fully Ethereum-equivalent and faster to enable real-time proof generation, they are making progress. Ethereum improvements like increasing gas costs for hash functions will also help. A long-term future of formally verifying ZK-EVM equivalence is promising but an open multi-ZK-EVM world seems a natural next step.\nThe transition to ZK-EVMs on layer 1 may start sooner than expected once Verkle trees and stateless clients are live, as clients start relying more on ZK-SNARKs. Though still a long journey, ZK-EVMs are poised to play an important role in Ethereum’s continued decentralization and scale.\nVitalik’s View One underdiscussed, but nevertheless very important, way in which Ethereum maintains its security and decentralization is its multi-client philosophy. Ethereum intentionally has no “reference client” that everyone runs by default: instead, there is a collaboratively-managed specification (these days written in the very human-readable but very slow Python) and there are multiple teams making implementations of the spec (also called “clients”), which is what users actually run.\nEach Ethereum node runs a consensus client and an execution client. As of today, no consensus or execution client makes up more than 2/3 of the network. If a client with less than 1/3 share in its category has a bug, the network would simply continue as normal. If a client with between 1/3 and 2/3 share in its category (so, Prysm, Lighthouse or Geth) has a bug, the chain would continue adding blocks, but it would stop finalizing blocks, giving time for developers to intervene.\nOne underdiscussed, but nevertheless very important, major upcoming transition in the way the Ethereum chain gets validated is the rise of ZK-EVMs. SNARKs proving EVM execution have been under development for years already, and the technology is actively being used by layer 2 protocols called ZK rollups. Some of these ZK rollups are active on mainnet today, with more coming soon. But in the longer term, ZK-EVMs are not just going to be for rollups; we want to use them to verify execution on layer 1 as well (see also: the Verge).\nOnce that happens, ZK-EVMs de-facto become a third type of Ethereum client, just as important to the network’s security as execution clients and consensus clients are today. And this naturally raises a question: how will ZK-EVMs interact with the multi-client philosophy? One of the hard parts is already done: we already have multiple ZK-EVM implementations that are being actively developed. But other hard parts remain: how would we actually make a “multi-client” ecosystem for ZK-proving correctness of Ethereum blocks? This question opens up some interesting technical challenges - and of course the looming question of whether or not the tradeoffs are worth it.\nWhat was the original motivation for Ethereum’s multi-client philosophy? Ethereum’s multi-client philosophy is a type of decentralization, and like decentralization in general, one can focus on either the technical benefits of architectural decentralization or the social benefits of political decentralization. Ultimately, the multi-client philosophy was motivated by both and serves both.\nArguments for technical decentralization The main benefit of technical decentralization is simple: it reduces the risk that one bug in one piece of software leads to a catastrophic breakdown of the entire network. A historical situation that exemplifies this risk is the 2010 Bitcoin overflow bug. At the time, the Bitcoin client code did not check that the sum of the outputs of a transaction does not overflow (wrap around to zero by summing to above the maximum integer of $2^{64} - 1$), and so someone made a transaction that did exactly that, giving themselves billions of bitcoins. The bug was discovered within hours, and a fix was rushed through and quickly deployed across the network, but had there been a mature ecosystem at the time, those coins would have been accepted by exchanges, bridges and other structures, and the attackers could have gotten away with a lot of money. If there had been five different Bitcoin clients, it would have been very unlikely that all of them had the same bug, and so there would have been an immediate split, and the side of the split that was buggy would have probably lost.\nThere is a tradeoff in using the multi-client approach to minimize the risk of catastrophic bugs: instead, you get consensus failure bugs. That is, if you have two clients, there is a risk that the clients have subtly different interpretations of some protocol rule, and while both interpretations are reasonable and do not allow stealing money, the disagreement would cause the chain to split in half. A serious split of that type happened once in Ethereum’s history (there have been other much smaller splits where very small portions of the network running old versions of the code forked off). Defenders of the single-client approach point to consensus failures as a reason to not have multiple implementations: if there is only one client, that one client will not disagree with itself. Their model of how number of clients translates into risk might look something like this:\nI, of course, disagree with this analysis. The crux of my disagreement is that (i) 2010-style catastrophic bugs matter too, and (ii) you never actually have only one client. The latter point is made most obvious by the Bitcoin fork of 2013: a chain split occurred because of a disagreement between two different versions of the Bitcoin client, one of which turned out to have an accidental and undocumented limit on the number of objects that could be modified in a single block. Hence, one client in theory is often two clients in practice, and five clients in theory might be six or seven clients in practice - so we should just take the plunge and go on the right side of the risk curve, and have at least a few different clients.\nArguments for political decentralization Monopoly client developers are in a position with a lot of political power. If a client developer proposes a change, and users disagree, theoretically they could refuse to download the updated version, or create a fork without it, but in practice it’s often difficult for users to do that. What if a disagreeable protocol change is bundled with a necessary security update? What if the main team threatens to quit if they don’t get their way? Or, more tamely, what if the monopoly client team ends up being the only group with the greatest protocol expertise, leaving the rest of the ecosystem in a poor position to judge technical arguments that the client team puts forward, leaving the client team with a lot of room to push their own particular goals and values, which might not match with the broader community?\nConcern about protocol politics, particularly in the context of the 2013-14 Bitcoin OP_RETURN wars where some participants were openly in favor of discriminating against particular usages of the chain, was a significant contributing factor in Ethereum’s early adoption of a multi-client philosophy, which was aimed to make it harder for a small group to make those kinds of decisions. Concerns specific to the Ethereum ecosystem - namely, avoiding concentration of power within the Ethereum Foundation itself - provided further support for this direction. In 2018, a decision was made to intentionally have the Foundation not make an implementation of the Ethereum PoS protocol (ie. what is now called a “consensus client”), leaving that task entirely to outside teams.\nHow will ZK-EVMs come in on layer 1 in the future? Today, ZK-EVMs are used in rollups. This increases scaling by allowing expensive EVM execution to happen only a few times off-chain, with everyone else simply verifying SNARKs posted on-chain that prove that the EVM execution was computed correctly. It also allows some data (particularly signatures) to not be included on-chain, saving on gas costs. This gives us a lot of scalability benefits, and the combination of scalable computation with ZK-EVMs and scalable data with data availability sampling could let us scale very far.\nHowever, the Ethereum network today also has a different problem, one that no amount of layer 2 scaling can solve by itself: the layer 1 is difficult to verify, to the point where not many users run their own node. Instead, most users simply trust third-party providers. Light clients such as Helios and Succinct are taking steps toward solving the problem, but a light client is far from a fully verifying node: a light client merely verifies the signatures of a random subset of validators called the sync committee, and does not verify that the chain actually follows the protocol rules. To bring us to a world where users can actually verify that the chain follows the rules, we would have to do something different.\nOption 1: constrict layer 1, force almost all activity to move to layer 2 We could over time reduce the layer 1 gas-per-block target down from 15 million to 1 million, enough for a block to contain a single SNARK and a few deposit and withdraw operations but not much else, and thereby force almost all user activity to move to layer 2 protocols. Such a design could still support many rollups committing in each block: we could use off-chain aggregation protocols run by customized builders to gather together SNARKs from multiple layer 2 protocols and combine them into a single SNARK. In such a world, the only function of layer 1 would be to be a clearinghouse for layer 2 protocols, verifying their proofs and occasionally facilitating large funds transfers between them.\nThis approach could work, but it has several important weaknesses:\nIt’s de-facto backwards-incompatible, in the sense that many existing L1-based applications become economically nonviable. User funds up to hundreds or thousands of dollars could get stuck as fees become so high that they exceed the cost of emptying those accounts. This could be addressed by letting users sign messages to opt in to an in-protocol mass migration to an L2 of their choice (see some early implementation ideas here), but this adds complexity to the transition, and making it truly cheap enough would require some kind of SNARK at layer 1 anyway. I’m generally a fan of breaking backwards compatibility when it comes to things like the SELFDESTRUCT opcode, but in this case the tradeoff seems much less favorable. It might still not make verification cheap enough. Ideally, the Ethereum protocol should be easy to verify not just on laptops but also inside phones, browser extensions, and even inside other chains. Syncing the chain for the first time, or after a long time offline, should also be easy. A laptop node could verify 1 million gas in ~20 ms, but even that implies 54 seconds to sync after one day offline (assuming single slot finality increases slot times to 32s), and for phones or browser extensions it would take a few hundred milliseconds per block and might still be a non-negligible battery drain. These numbers are manageable, but they are not ideal. Even in an L2-first ecosystem, there are benefits to L1 being at least somewhat affordable. Validiums can benefit from a stronger security model if users can withdraw their funds if they notice that new state data is no longer being made available. Arbitrage becomes more efficient, especially for smaller tokens, if the minimum size of an economically viable cross-L2 direct transfer is smaller. Hence, it seems more reasonable to try to find a way to use ZK-SNARKs to verify the layer 1 itself.\nOption 2: SNARK-verify the layer 1 A type 1 (fully Ethereum-equivalent) ZK-EVM can be used to verify the EVM execution of a (layer 1) Ethereum block. We could write more SNARK code to also verify the consensus side of a block. This would be a challenging engineering problem: today, ZK-EVMs take minutes to hours to verify Ethereum blocks, and generating proofs in real time would require one or more of (i) improvements to Ethereum itself to remove SNARK-unfriendly components, (ii) either large efficiency gains with specialized hardware, and (iii) architectural improvements with much more parallelization. However, there is no fundamental technological reason why it cannot be done - and so I expect that, even if it takes many years, it will be done.\nHere is where we see the intersection with the multi-client paradigm: if we use ZK-EVMs to verify layer 1, which ZK-EVM do we use?\nI see three options:\nSingle ZK-EVM: abandon the multi-client paradigm, and choose a single ZK-EVM that we use to verify blocks. Closed multi ZK-EVM: agree on and enshrine in consensus a specific set of multiple ZK-EVMs, and have a consensus-layer protocol rule that a block needs proofs from more than half of the ZK-EVMs in that set to be considered valid. Open multi ZK-EVM: different clients have different ZK-EVM implementations, and each client waits for a proof that is compatible with its own implementation before accepting a block as valid. To me, (3) seems ideal, at least until and unless our technology improves to the point where we can formally prove that all of the ZK-EVM implementations are equivalent to each other, at which point we can just pick whichever one is most efficient. (1) would sacrifice the benefits of the multi-client paradigm, and (2) would close off the possibility of developing new clients and lead to a more centralized ecosystem. (3) has challenges, but those challenges seem smaller than the challenges of the other two options, at least for now.\nImplementing (3) would not be too hard: one might have a p2p sub-network for each type of proof, and a client that uses one type of proof would listen on the corresponding sub-network and wait until they receive a proof that their verifier recognizes as valid.\nThe two main challenges of (3) are likely the following:\nThe latency challenge: a malicious attacker could publish a block late, along with a proof valid for one client. It would realistically take a long time (even if eg. 15 seconds) to generate proofs valid for other clients. This time would be long enough to potentially create a temporary fork and disrupt the chain for a few slots. Data inefficiency: one benefit of ZK-SNARKs is that data that is only relevant to verification (sometimes called “witness data”) could be removed from a block. For example, once you’ve verified a signature, you don’t need to keep the signature in a block, you could just store a single bit saying that the signature is valid, along with a single proof in the block confirming that all of the valid signatures exist. However, if we want it to be possible to generate proofs of multiple types for a block, the original signatures would need to actually be published. The latency challenge could be addressed by being careful when designing the single-slot finality protocol. Single-slot finality protocols will likely require more than two rounds of consensus per slot, and so one could require the first round to include the block, and only require nodes to verify proofs before signing in the third (or final) round. This ensures that a significant time window is always available between the deadline for publishing a block and the time when it’s expected for proofs to be available.\nThe data efficiency issue would have to be addressed by having a separate protocol for aggregating verification-related data. For signatures, we could use BLS aggregation, which ERC-4337 already supports. Another major category of verification-related data is ZK-SNARKs used for privacy. Fortunately, these often tend to have their own aggregation protocols.\nIt is also worth mentioning that SNARK-verifying the layer 1 has an important benefit: the fact that on-chain EVM execution no longer needs to be verified by every node makes it possible to greatly increase the amount of EVM execution taking place. This could happen either by greatly increasing the layer 1 gas limit, or by introducing enshrined rollups, or both.\nConclusions Making an open multi-client ZK-EVM ecosystem work well will take a lot of work. But the really good news is that much of this work is happening or will happen anyway:\nWe have multiple strong ZK-EVM implementations already. These implementations are not yet type 1 (fully Ethereum-equivalent), but many of them are actively moving in that direction. The work on light clients such as Helios and Succinct may eventually turn into a more full SNARK-verification of the PoS consensus side of the Ethereum chain. Clients will likely start experimenting with ZK-EVMs to prove Ethereum block execution on their own, especially once we have stateless clients and there’s no technical need to directly re-execute every block to maintain the state. We will probably get a slow and gradual transition from clients verifying Ethereum blocks by re-executing them to most clients verifying Ethereum blocks by checking SNARK proofs. The ERC-4337 and PBS ecosystems are likely to start working with aggregation technologies like BLS and proof aggregation pretty soon, in order to save on gas costs. On BLS aggregation, work has already started. With these technologies in place, the future looks very good. Ethereum blocks would be smaller than today, anyone could run a fully verifying node on their laptop or even their phone or inside a browser extension, and this would all happen while preserving the benefits of Ethereum’s multi-client philosophy.\nIn the longer-term future, of course anything could happen. Perhaps AI will super-charge formal verification to the point where it can easily prove ZK-EVM implementations equivalent and identify all the bugs that cause differences between them. Such a project may even be something that it might be practical to start working on now. If such a formal verification-based approach succeeds, different mechanisms would need to be put in place to ensure continued political decentralization of the protocol; perhaps at that point, the protocol would be considered “complete” and immutability norms would be stronger. But even if that is the longer-term future, the open multi-client ZK-EVM world seems like a natural stepping stone that is likely to happen anyway.\nIn the nearer term, this is still a long journey. ZK-EVMs are here, but ZK-EVMs becoming truly viable at layer 1 would require them to become type 1, and make proving fast enough that it can happen in real time. With enough parallelization, this is doable, but it will still be a lot of work to get there. Consensus changes like raising the gas cost of KECCAK, SHA256 and other hash function precompiles will also be an important part of the picture. That said, the first steps of the transition may happen sooner than we expect: once we switch to Verkle trees and stateless clients, clients could start gradually using ZK-EVMs, and a transition to an “open multi-ZK-EVM” world could start happening all on its own.\nCredits : Vitalik Buterin - Founder of Ethereum\n","wordCount":"3691","inLanguage":"en","image":"http://localhost:1313/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2023-04-10T00:00:00Z","dateModified":"2023-04-10T00:00:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:1313/posts/2023-04-10-how-ethereum-makes-decentralization-possible/"},"publisher":{"@type":"Organization","name":"Ram's Website","logo":{"@type":"ImageObject","url":"http://localhost:1313/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://localhost:1313/ accesskey=h title=" root@bhaskarvilles ⚕ (Alt + H)"><img src=http://localhost:1313/apple-touch-icon.png alt aria-label=logo height=35> root@bhaskarvilles ⚕</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://localhost:1313/categories/ title="🚀 categories"><span>🚀 categories</span></a></li><li><a href=http://localhost:1313/tags/ title="💥 tags"><span>💥 tags</span></a></li><li><a href=https://kerdos.io title=company><span>company</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://localhost:1313/>Home</a>&nbsp;»&nbsp;<a href=http://localhost:1313/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">The Rise of ZK-EVMs: How Ethereum's Multi-Client Philosophy Enables Continued Decentralization</h1><div class=post-meta><span title='2023-04-10 00:00:00 +0000 UTC'>April 10, 2023</span>&nbsp;·&nbsp;18 min&nbsp;·&nbsp;3691 words&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/bhaskarvilles/content/posts/2023-04-10-how-ethereum-makes-decentralization-possible.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><h2 id=my-thoughts-on-evms-multi-client-repository>My thoughts on EVMs Multi Client repository<a hidden class=anchor aria-hidden=true href=#my-thoughts-on-evms-multi-client-repository>#</a></h2><p>One important aspect of Ethereum&rsquo;s security and decentralization is its multi-client philosophy. Instead of relying on a single reference client, Ethereum has a specification written in Python and multiple independent implementations of the spec called clients. Each node runs a consensus client to validate blocks and an execution client to check state transitions. Currently, no single client makes up more than two-thirds of either category. This ensures that bugs in any one client will not cripple the network.</p><p>An upcoming transition in Ethereum is the rise of Zero-Knowledge Ethereum Virtual Machines or ZK-EVMs. ZK-EVMs use zero-knowledge proofs to verify EVM execution. They are currently used by layer 2 protocols called ZK rollups to scale Ethereum. In the future, ZK-EVMs could also be used to verify layer 1 Ethereum blocks. This raises the question of how ZK-EVMs will fit into Ethereum&rsquo;s multi-client philosophy. While there are multiple ZK-EVM implementations, making them work together as &ldquo;multi-clients&rdquo; will be challenging. However, the benefits may outweigh the costs.</p><p><strong>Why did Ethereum adopt a multi-client philosophy?</strong></p><p>Ethereum&rsquo;s multi-client philosophy improves both technical and political decentralization.</p><p>Technically, it reduces the risk of bugs in a single client disrupting the network. For example, if there was only one client, a catastrophic bug could cripple the entire network. With multiple clients, the network is more resilient. While multi-clients introduce the risk of consensus failures where clients disagree, in practice there are always multiple versions of a single client. So multi-clients likely reduce risk overall.</p><p>Politically, multi-clients prevent too much control from concentrating with any one team. If there was only one client, its developers would have significant power over the protocol. They could propose controversial changes or threaten to quit if they don&rsquo;t get their way. Multi-clients make it harder for any one group to control the protocol.</p><p><strong>How will ZK-EVMs be used on layer 1?</strong></p><p>There are two options for using ZK-EVMs on layer 1:</p><ol><li><p>Constrict layer 1 and force activity to layer 2. This would limit layer 1 to verifying SNARKs and facilitating transfers between layer 2s. While this could work, it may not reduce costs enough for most users to verify the chain and it risks breaking compatibility with existing applications.</p></li><li><p>Use ZK-EVMs to SNARK-verify layer 1. ZK-EVMs could generate proofs that verify the EVM execution and consensus of layer 1 blocks. This is challenging to implement but technically feasible and allows layer 1 to remain useful. The main question is which ZK-EVMs to use:</p></li></ol><ul><li><p>Single ZK-EVM: Pick one ZK-EVM to verify all blocks. This sacrifices the benefits of multiple clients.</p></li><li><p>Closed multi ZK-EVM: Choose a fixed set of ZK-EVMs and require proofs from a majority to verify blocks. This limits innovation in new ZK-EVMs.</p></li><li><p>Open multi ZK-EVM: Different clients use different ZK-EVMs and wait for compatible proofs to verify blocks. This is ideal but introduces latency and data inefficiency challenges. With careful protocol design and aggregation methods, these challenges can be addressed.</p></li></ul><p>Using ZK-EVMs to SNARK-verify layer 1 also allows greatly increasing layer 1 capacity since clients no longer need to re-execute every transaction.</p><p><strong>So purely, i will say that</strong></p><p>An open multi-client ZK-EVM ecosystem will require substantial work but many of the necessary technologies already exist or are in development. Multiple ZK-EVM implementations, light clients becoming full SNARK-verifiers, gradual transitions to SNARKs, and aggregation methods will all help in building this ecosystem.</p><p>While ZK-EVMs still need to become fully Ethereum-equivalent and faster to enable real-time proof generation, they are making progress. Ethereum improvements like increasing gas costs for hash functions will also help. A long-term future of formally verifying ZK-EVM equivalence is promising but an open multi-ZK-EVM world seems a natural next step.</p><p>The transition to ZK-EVMs on layer 1 may start sooner than expected once Verkle trees and stateless clients are live, as clients start relying more on ZK-SNARKs. Though still a long journey, ZK-EVMs are poised to play an important role in Ethereum&rsquo;s continued decentralization and scale.</p><h2 id=vitaliks-view>Vitalik&rsquo;s View<a hidden class=anchor aria-hidden=true href=#vitaliks-view>#</a></h2><p>One underdiscussed, but nevertheless very important, way in which Ethereum maintains its security and decentralization is its <strong>multi-client philosophy</strong>. Ethereum intentionally has no &ldquo;reference client&rdquo; that everyone runs by default: instead, there is a collaboratively-managed <strong>specification</strong> (these days <a href=https://github.com/ethereum/consensus-specs>written</a> in the very human-readable but very slow <a href=https://github.com/ethereum/execution-specs>Python</a>) and there are multiple teams making <strong>implementations</strong> of the spec (also called &ldquo;<strong>clients</strong>&rdquo;), which is what users actually run.</p><p><img loading=lazy src=https://vitalik.ca/images/zkmulticlient/clientdistribution.png alt></p><p>Each Ethereum node runs a consensus client and an execution client. As of today, no consensus or execution client makes up more than 2/3 of the network. If a client with less than 1/3 share in its category has a bug, the network would simply continue as normal. If a client with between 1/3 and 2/3 share in its category (so, Prysm, Lighthouse or Geth) has a bug, the chain would continue adding blocks, but it would stop finalizing blocks, giving time for developers to intervene.</p><p>One underdiscussed, but nevertheless very important, major upcoming transition in the way the Ethereum chain gets validated is the rise of <strong>ZK-EVMs</strong>. <a href=https://vitalik.ca/general/2022/08/04/zkevm.html>SNARKs proving EVM execution</a> have been under development for years already, and the technology is actively being used by layer 2 protocols called <a href=https://vitalik.ca/general/2021/01/05/rollup.html>ZK rollups</a>. Some of these ZK rollups are <a href=https://blog.matter-labs.io/gm-zkevm-171b12a26b36>active</a> on <a href=https://polygon.technology/polygon-zkevm>mainnet</a> today, with <a href=https://scroll.io/>more</a> <a href=https://taiko.xyz/>coming</a> <a href=https://www.kakarot.org/>soon</a>. But in the longer term, ZK-EVMs are not just going to be for rollups; we want to use them to verify execution on layer 1 as well (see also: <a href=https://twitter.com/VitalikButerin/status/1588669782471368704>the Verge</a>).</p><p>Once that happens, ZK-EVMs de-facto become a third type of Ethereum client, just as important to the network&rsquo;s security as execution clients and consensus clients are today. And this naturally raises a question: how will ZK-EVMs interact with the multi-client philosophy? One of the hard parts is already done: we already have multiple ZK-EVM implementations that are being actively developed. But other hard parts remain: how would we actually make a &ldquo;multi-client&rdquo; ecosystem for ZK-proving correctness of Ethereum blocks? This question opens up some interesting technical challenges - and of course the looming question of whether or not the tradeoffs are worth it.</p><h2 id=what-was-the-original-motivation-for-ethereums-multi-client-philosophy>What was the original motivation for Ethereum&rsquo;s multi-client philosophy?<a hidden class=anchor aria-hidden=true href=#what-was-the-original-motivation-for-ethereums-multi-client-philosophy>#</a></h2><p>Ethereum&rsquo;s multi-client philosophy is a type of decentralization, and like <a href=https://medium.com/@VitalikButerin/the-meaning-of-decentralization-a0c92b76a274>decentralization in general</a>, one can focus on either the technical benefits of architectural decentralization or the social benefits of political decentralization. Ultimately, the multi-client philosophy was motivated by both and serves both.</p><h3 id=arguments-for-technical-decentralization>Arguments for technical decentralization<a hidden class=anchor aria-hidden=true href=#arguments-for-technical-decentralization>#</a></h3><p>The main benefit of technical decentralization is simple: it reduces the risk that one bug in one piece of software leads to a catastrophic breakdown of the entire network. A historical situation that exemplifies this risk is the <a href=https://news.bitcoin.com/bitcoin-history-part-10-the-184-billion-btc-bug/>2010 Bitcoin overflow bug</a>. At the time, the Bitcoin client code did not check that the sum of the outputs of a transaction does not overflow (wrap around to zero by summing to above the maximum integer of $2^{64} - 1$), and so someone made a transaction that did exactly that, giving themselves billions of bitcoins. The bug was discovered within hours, and a fix was rushed through and quickly deployed across the network, but had there been a mature ecosystem at the time, those coins would have been accepted by exchanges, bridges and other structures, and the attackers could have gotten away with a lot of money. If there had been five different Bitcoin clients, it would have been very unlikely that all of them had the same bug, and so there would have been an immediate split, and the side of the split that was buggy would have probably lost.</p><p>There is a tradeoff in using the multi-client approach to minimize the risk of catastrophic bugs: instead, you get <strong>consensus failure</strong> bugs. That is, if you have two clients, there is a risk that the clients have subtly different interpretations of some protocol rule, and while both interpretations are reasonable and do not allow stealing money, the disagreement would cause the chain to split in half. A serious split of that type happened <a href=https://blog.ethereum.org/2016/11/25/security-alert-11242016-consensus-bug-geth-v1-4-19-v1-5-2>once in Ethereum&rsquo;s history</a> (there have been other much smaller splits where very small portions of the network running old versions of the code forked off). Defenders of the single-client approach point to consensus failures as a reason to not have multiple implementations: if there is only one client, that one client will not disagree with itself. Their model of how number of clients translates into risk might look something like this:</p><p><img loading=lazy src=https://vitalik.ca/images/zkmulticlient/riskchart.png alt></p><p>I, of course, disagree with this analysis. The crux of my disagreement is that (i) 2010-style catastrophic bugs matter too, and (ii) <strong>you never <em>actually</em> have only one client</strong>. The latter point is made most obvious by the <a href=https://bitcoinmagazine.com/technical/bitcoin-network-shaken-by-blockchain-fork-1363144448>Bitcoin fork of 2013</a>: a chain split occurred because of a disagreement between <em>two different versions</em> of the Bitcoin client, one of which turned out to have an accidental and undocumented limit on the number of objects that could be modified in a single block. Hence, one client in theory is often two clients in practice, and five clients in theory might be six or seven clients in practice - so we should just take the plunge and go on the right side of the risk curve, and have at least a few different clients.</p><h3 id=arguments-for-political-decentralization>Arguments for political decentralization<a hidden class=anchor aria-hidden=true href=#arguments-for-political-decentralization>#</a></h3><p>Monopoly client developers are in a position with a lot of political power. If a client developer proposes a change, and users disagree, <em>theoretically</em> they could refuse to download the updated version, or create a fork without it, but <em>in practice</em> it&rsquo;s often difficult for users to do that. What if a disagreeable protocol change is bundled with a necessary security update? What if the main team threatens to quit if they don&rsquo;t get their way? Or, more tamely, what if the monopoly client team ends up being the only group with the greatest protocol expertise, leaving the rest of the ecosystem in a poor position to judge technical arguments that the client team puts forward, leaving the client team with a lot of room to push their own particular goals and values, which might not match with the broader community?</p><p>Concern about protocol politics, particularly in the context of the <a href=https://blog.bitmex.com/dapps-or-only-bitcoin-transactions-the-2014-debate/>2013-14 Bitcoin OP_RETURN wars</a> where some participants were openly in favor of discriminating against particular usages of the chain, was a significant contributing factor in Ethereum&rsquo;s early adoption of a multi-client philosophy, which was aimed to make it harder for a small group to make those kinds of decisions. Concerns specific to the Ethereum ecosystem - namely, avoiding concentration of power within the Ethereum Foundation itself - provided further support for this direction. In 2018, a decision was made to intentionally have the Foundation <em>not</em> make an implementation of the Ethereum PoS protocol (ie. what is now called a &ldquo;consensus client&rdquo;), leaving that task entirely to outside teams.</p><h2 id=how-will-zk-evms-come-in-on-layer-1-in-the-future>How will ZK-EVMs come in on layer 1 in the future?<a hidden class=anchor aria-hidden=true href=#how-will-zk-evms-come-in-on-layer-1-in-the-future>#</a></h2><p>Today, ZK-EVMs are used in rollups. This increases scaling by allowing expensive EVM execution to happen only a few times off-chain, with everyone else simply verifying <a href=https://vitalik.ca/general/2021/01/26/snarks.html>SNARKs</a> posted on-chain that prove that the EVM execution was computed correctly. It also allows some data (particularly signatures) to not be included on-chain, saving on gas costs. This gives us a lot of scalability benefits, and the combination of scalable computation with ZK-EVMs and scalable data with <a href=https://hackmd.io/@vbuterin/sharding_proposal#ELI5-data-availability-sampling>data availability sampling</a> could let us scale very far.</p><p>However, the Ethereum network today also has a different problem, one that no amount of layer 2 scaling can solve by itself: the layer 1 is difficult to verify, to the point where not many users run their own node. Instead, most users simply trust third-party providers. Light clients such as <a href=https://a16zcrypto.com/content/article/building-helios-ethereum-light-client/>Helios</a> and <a href=https://www.succinct.xyz/>Succinct</a> are taking steps toward solving the problem, but a light client is far from a fully verifying node: a light client merely verifies the signatures of a random subset of validators called the <a href=https://github.com/ethereum/annotated-spec/blob/master/altair/sync-protocol.md>sync committee</a>, and does not verify that the chain actually follows the protocol rules. To bring us to a world where users can actually verify that the chain follows the rules, we would have to do something different.</p><h3 id=option-1-constrict-layer-1-force-almost-all-activity-to-move-to-layer-2>Option 1: constrict layer 1, force almost all activity to move to layer 2<a hidden class=anchor aria-hidden=true href=#option-1-constrict-layer-1-force-almost-all-activity-to-move-to-layer-2>#</a></h3><p>We could over time reduce the layer 1 gas-per-block target down from 15 million to 1 million, enough for a block to contain a single SNARK and a few deposit and withdraw operations but not much else, and thereby force almost all user activity to move to layer 2 protocols. Such a design could still support many rollups committing in each block: we could use <a href=https://vitalik.ca/general/2022/09/17/layer_3.html#rollups-and-validiums-have-a-confirmation-time-vs-fixed-cost-tradeoff.-layer-3s-can-help-fix-this.-but-what-else-can>off-chain aggregation protocols</a> run by customized builders to gather together SNARKs from multiple layer 2 protocols and combine them into a single SNARK. <strong>In such a world, the <em>only</em> function of layer 1 would be to be a clearinghouse for layer 2 protocols, verifying their proofs and occasionally facilitating large funds transfers between them</strong>.</p><p><img loading=lazy src=https://vitalik.ca/images/zkmulticlient/proofaggregation.png alt></p><p>This approach could work, but it has several important weaknesses:</p><ul><li><strong>It&rsquo;s de-facto backwards-incompatible</strong>, in the sense that many existing L1-based applications become economically nonviable. User funds up to hundreds or thousands of dollars could get stuck as fees become so high that they exceed the cost of emptying those accounts. This could be addressed by letting users sign messages to opt in to an in-protocol mass migration to an L2 of their choice (see some <a href=https://ethereum-magicians.org/t/some-medium-term-dust-cleanup-ideas/6287>early implementation ideas here</a>), but this adds complexity to the transition, and making it truly cheap enough would require <em>some</em> kind of SNARK at layer 1 anyway. I&rsquo;m generally a fan of breaking backwards compatibility when it comes to <a href=https://hackmd.io/@vbuterin/selfdestruct>things like the SELFDESTRUCT opcode</a>, but in this case the tradeoff seems much less favorable.</li><li><strong>It might still not make verification cheap enough</strong>. Ideally, the Ethereum protocol should be easy to verify not just on laptops but also inside phones, browser extensions, and even inside other chains. Syncing the chain for the first time, or after a long time offline, should also be easy. A laptop node could verify 1 million gas in ~20 ms, but even that implies 54 seconds to sync after one day offline (assuming <a href=https://notes.ethereum.org/@vbuterin/single_slot_finality>single slot finality</a> increases slot times to 32s), and for phones or browser extensions it would take a few hundred milliseconds per block and might still be a non-negligible battery drain. These numbers are manageable, but they are not ideal.</li><li><strong>Even in an L2-first ecosystem, there are benefits to L1 being at least somewhat affordable</strong>. <a href=https://ethereum.org/en/developers/docs/scaling/validium/>Validiums</a> can benefit from a stronger security model if users can withdraw their funds if they notice that new state data is no longer being made available. Arbitrage becomes more efficient, especially for smaller tokens, if the minimum size of an economically viable cross-L2 direct transfer is smaller.</li></ul><p>Hence, it seems more reasonable to try to find a way to use ZK-SNARKs to verify the layer 1 itself.</p><h3 id=option-2-snark-verify-the-layer-1>Option 2: SNARK-verify the layer 1<a hidden class=anchor aria-hidden=true href=#option-2-snark-verify-the-layer-1>#</a></h3><p>A <a href=https://vitalik.ca/general/2022/08/04/zkevm.html#type-1-fully-ethereum-equivalent>type 1 (fully Ethereum-equivalent) ZK-EVM</a> can be used to verify the EVM execution of a (layer 1) Ethereum block. We could write more SNARK code to also verify the consensus side of a block. This would be a challenging engineering problem: today, ZK-EVMs take minutes to hours to verify Ethereum blocks, and generating proofs in real time would require one or more of (i) improvements to Ethereum itself to remove SNARK-unfriendly components, (ii) either large efficiency gains with specialized hardware, and (iii) architectural improvements with much more parallelization. However, there is no fundamental technological reason why it cannot be done - and so I expect that, even if it takes many years, it will be done.</p><p><strong>Here is where we see the intersection with the multi-client paradigm: if we use ZK-EVMs to verify layer 1, which ZK-EVM do we use?</strong></p><p>I see three options:</p><ol><li><strong>Single ZK-EVM</strong>: abandon the multi-client paradigm, and choose a single ZK-EVM that we use to verify blocks.</li><li><strong>Closed multi ZK-EVM</strong>: agree on and enshrine in consensus a specific set of multiple ZK-EVMs, and have a consensus-layer protocol rule that a block needs proofs from more than half of the ZK-EVMs in that set to be considered valid.</li><li><strong>Open multi ZK-EVM</strong>: different clients have different ZK-EVM implementations, and each client waits for a proof that is compatible with its own implementation before accepting a block as valid.</li></ol><p>To me, (3) seems ideal, at least until and unless our technology improves to the point where we can <a href=https://en.wikipedia.org/wiki/Formal_verification>formally prove</a> that all of the ZK-EVM implementations are equivalent to each other, at which point we can just pick whichever one is most efficient. (1) would sacrifice the benefits of the multi-client paradigm, and (2) would close off the possibility of developing new clients and lead to a more centralized ecosystem. (3) has challenges, but those challenges seem smaller than the challenges of the other two options, at least for now.</p><p>Implementing (3) would not be too hard: one might have a p2p sub-network for each type of proof, and a client that uses one type of proof would listen on the corresponding sub-network and wait until they receive a proof that their verifier recognizes as valid.</p><p>The two main challenges of (3) are likely the following:</p><ul><li><strong>The latency challenge</strong>: a malicious attacker could publish a block late, along with a proof valid for one client. It would realistically take a long time (even if eg. 15 seconds) to generate proofs valid for other clients. This time would be long enough to potentially create a temporary fork and disrupt the chain for a few slots.</li><li><strong>Data inefficiency</strong>: one benefit of ZK-SNARKs is that data that is only relevant to <em>verification</em> (sometimes called &ldquo;witness data&rdquo;) could be removed from a block. For example, once you&rsquo;ve verified a signature, you don&rsquo;t need to keep the signature in a block, you could just store a single bit saying that the signature is valid, along with a single proof in the block confirming that all of the valid signatures exist. However, if we want it to be possible to generate proofs of multiple types for a block, the original signatures would need to actually be published.</li></ul><p>The latency challenge could be addressed by being careful when designing the single-slot finality protocol. Single-slot finality protocols will likely require more than two rounds of consensus per slot, and so one could require the first round to include the block, and only require nodes to verify proofs before signing in the third (or final) round. This ensures that a significant time window is always available between the deadline for publishing a block and the time when it&rsquo;s expected for proofs to be available.</p><p>The data efficiency issue would have to be addressed by having a separate protocol for aggregating verification-related data. For signatures, we could use <a href=https://ethresear.ch/t/adding-cross-transaction-bls-signature-aggregation-to-ethereum/7844>BLS aggregation</a>, which <a href=https://github.com/eth-infinitism/account-abstraction/pull/92>ERC-4337 already supports</a>. Another major category of verification-related data is ZK-SNARKs <a href=https://vitalik.ca/general/2022/06/15/using_snarks.html>used for privacy</a>. Fortunately, these often tend to <a href=https://vitalik.ca/general/2021/11/05/halo.html>have their own aggregation protocols</a>.</p><p>It is also worth mentioning that SNARK-verifying the layer 1 has an important <em>benefit</em>: the fact that on-chain EVM execution no longer needs to be verified by every node makes it possible to greatly increase the amount of EVM execution taking place. This could happen either by greatly increasing the layer 1 gas limit, or by introducing <a href=https://www.reddit.com/r/ethereum/comments/vrx9xe/comment/if7auu7/>enshrined rollups</a>, or both.</p><h2 id=conclusions>Conclusions<a hidden class=anchor aria-hidden=true href=#conclusions>#</a></h2><p>Making an open multi-client ZK-EVM ecosystem work well will take a lot of work. But the really good news is that much of this work is happening or will happen anyway:</p><ul><li><a href=https://github.com/matter-labs/zksync>We</a> have <a href=https://github.com/privacy-scaling-explorations/zkevm-specs>multiple</a> strong <a href=https://github.com/0xpolygonhermez>ZK-EVM</a> implementations <a href=https://github.com/sayajin-labs/kakarot>already</a>. These implementations are not yet <a href=https://vitalik.ca/general/2022/08/04/zkevm.html>type 1</a> (fully Ethereum-equivalent), but many of them are actively moving in that direction.</li><li>The work on light clients such as <a href=https://a16zcrypto.com/content/article/building-helios-ethereum-light-client/>Helios</a> and <a href=https://www.succinct.xyz/>Succinct</a> may eventually turn into a more full SNARK-verification of the PoS consensus side of the Ethereum chain.</li><li>Clients will likely start experimenting with ZK-EVMs to prove Ethereum block execution on their own, especially once we have <a href=https://dankradfeist.de/ethereum/2021/02/14/why-stateless.html>stateless clients</a> and there&rsquo;s no technical need to directly re-execute every block to maintain the state. We will probably get a slow and gradual transition from clients verifying Ethereum blocks by re-executing them to most clients verifying Ethereum blocks by checking SNARK proofs.</li><li>The ERC-4337 and PBS ecosystems are likely to start working with aggregation technologies like BLS and proof aggregation pretty soon, in order to save on gas costs. On BLS aggregation, <a href=https://medium.com/privacy-scaling-explorations/bls-wallet-bundling-up-data-fb5424d3bdd3>work has already started</a>.</li></ul><p>With these technologies in place, the future looks very good. Ethereum blocks would be smaller than today, anyone could run a fully verifying node on their laptop or even their phone or inside a browser extension, and this would all happen while preserving the benefits of Ethereum&rsquo;s multi-client philosophy.</p><p>In the longer-term future, of course anything could happen. Perhaps AI will super-charge formal verification to the point where it can easily prove ZK-EVM implementations equivalent and identify all the bugs that cause differences between them. Such a project may even be something that it might be practical to start working on now. If such a formal verification-based approach succeeds, different mechanisms would need to be put in place to ensure continued political decentralization of the protocol; perhaps at that point, the protocol would be considered &ldquo;complete&rdquo; and immutability norms would be stronger. But even if that is the longer-term future, the open multi-client ZK-EVM world seems like a natural stepping stone that is likely to happen anyway.</p><p>In the nearer term, this is still a long journey. ZK-EVMs <em>are</em> here, but ZK-EVMs becoming truly viable at layer 1 would require them to become type 1, and make proving fast enough that it can happen in real time. With enough parallelization, this is doable, but it will still be a lot of work to get there. Consensus changes like raising the gas cost of KECCAK, SHA256 and other hash function precompiles will also be an important part of the picture. That said, the first steps of the transition may happen sooner than we expect: once we switch to <a href=https://vitalik.ca/general/2021/06/18/verkle.html>Verkle trees</a> and stateless clients, clients could start gradually using ZK-EVMs, and a transition to an &ldquo;open multi-ZK-EVM&rdquo; world could start happening all on its own.</p><p>Credits : <a href=https:vitalik.ca>Vitalik Buterin</a> - Founder of <a href=https://ethereum.org>Ethereum</a></p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=http://localhost:1313/posts/2023-04-15-awesome-recon-tools/><span class=title>« Prev</span><br><span>Tools for reconnaissance and footprinting</span>
</a><a class=next href=http://localhost:1313/posts/2023-03-07-advanced-seo-with-ai/><span class=title>Next »</span><br><span>Advanced SEO with AI: How Machine Learning and Natural Language Processing Are Changing the Game</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share The Rise of ZK-EVMs: How Ethereum's Multi-Client Philosophy Enables Continued Decentralization on x" href="https://x.com/intent/tweet/?text=The%20Rise%20of%20ZK-EVMs%3a%20How%20Ethereum%27s%20Multi-Client%20Philosophy%20Enables%20Continued%20Decentralization&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2f2023-04-10-how-ethereum-makes-decentralization-possible%2f&amp;hashtags="><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share The Rise of ZK-EVMs: How Ethereum's Multi-Client Philosophy Enables Continued Decentralization on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2f2023-04-10-how-ethereum-makes-decentralization-possible%2f&amp;title=The%20Rise%20of%20ZK-EVMs%3a%20How%20Ethereum%27s%20Multi-Client%20Philosophy%20Enables%20Continued%20Decentralization&amp;summary=The%20Rise%20of%20ZK-EVMs%3a%20How%20Ethereum%27s%20Multi-Client%20Philosophy%20Enables%20Continued%20Decentralization&amp;source=http%3a%2f%2flocalhost%3a1313%2fposts%2f2023-04-10-how-ethereum-makes-decentralization-possible%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share The Rise of ZK-EVMs: How Ethereum's Multi-Client Philosophy Enables Continued Decentralization on reddit" href="https://reddit.com/submit?url=http%3a%2f%2flocalhost%3a1313%2fposts%2f2023-04-10-how-ethereum-makes-decentralization-possible%2f&title=The%20Rise%20of%20ZK-EVMs%3a%20How%20Ethereum%27s%20Multi-Client%20Philosophy%20Enables%20Continued%20Decentralization"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share The Rise of ZK-EVMs: How Ethereum's Multi-Client Philosophy Enables Continued Decentralization on facebook" href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2flocalhost%3a1313%2fposts%2f2023-04-10-how-ethereum-makes-decentralization-possible%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share The Rise of ZK-EVMs: How Ethereum's Multi-Client Philosophy Enables Continued Decentralization on whatsapp" href="https://api.whatsapp.com/send?text=The%20Rise%20of%20ZK-EVMs%3a%20How%20Ethereum%27s%20Multi-Client%20Philosophy%20Enables%20Continued%20Decentralization%20-%20http%3a%2f%2flocalhost%3a1313%2fposts%2f2023-04-10-how-ethereum-makes-decentralization-possible%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share The Rise of ZK-EVMs: How Ethereum's Multi-Client Philosophy Enables Continued Decentralization on telegram" href="https://telegram.me/share/url?text=The%20Rise%20of%20ZK-EVMs%3a%20How%20Ethereum%27s%20Multi-Client%20Philosophy%20Enables%20Continued%20Decentralization&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2f2023-04-10-how-ethereum-makes-decentralization-possible%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share The Rise of ZK-EVMs: How Ethereum's Multi-Client Philosophy Enables Continued Decentralization on ycombinator" href="https://news.ycombinator.com/submitlink?t=The%20Rise%20of%20ZK-EVMs%3a%20How%20Ethereum%27s%20Multi-Client%20Philosophy%20Enables%20Continued%20Decentralization&u=http%3a%2f%2flocalhost%3a1313%2fposts%2f2023-04-10-how-ethereum-makes-decentralization-possible%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=http://localhost:1313/>Ram's Website</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>